<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chriszhuang.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录  几个常识 Makefile 介绍 Makefile 的细节 使用变量和函数 make 的运行 隐含规则 使用 make 更新函数库文件">
<meta property="og:type" content="article">
<meta property="og:title" content="How to Use Makefile">
<meta property="og:url" content="https://chriszhuang.top/2021/04/08/How-to-use-Makefile/index.html">
<meta property="og:site_name" content="Qurak">
<meta property="og:description" content="目录  几个常识 Makefile 介绍 Makefile 的细节 使用变量和函数 make 的运行 隐含规则 使用 make 更新函数库文件">
<meta property="og:locale">
<meta property="article:published_time" content="2021-04-07T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-26T02:54:10.000Z">
<meta property="article:author" content="Chris">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Makefile">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chriszhuang.top/2021/04/08/How-to-use-Makefile/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>How to Use Makefile | Qurak</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qurak</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Make Code Talk</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://chriszhuang.top/2021/04/08/How-to-use-Makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/zhuang-jiaxin_gitee/pictures/raw/master/img/0df431adcbef76096e34ebdc26dda3cc7cd99eb1-20210706060646187.jpeg">
      <meta itemprop="name" content="Chris">
      <meta itemprop="description" content=""I hope that I am a pioneer and my efforts can bring better technology and things to everyone."">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qurak">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          How to Use Makefile
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-08T00:00:00+08:00">2021-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-26 10:54:10" itemprop="dateModified" datetime="2021-04-26T10:54:10+08:00">2021-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">程序开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3>
<ul>
<li>几个常识</li>
<li>Makefile 介绍</li>
<li>Makefile 的细节</li>
<li>使用变量和函数</li>
<li>make 的运行</li>
<li>隐含规则</li>
<li>使用 make 更新函数库文件</li>
</ul>
<span id="more"></span>
<h3 id="一-几个常识"><a class="markdownIt-Anchor" href="#一-几个常识"></a> 一、几个常识</h3>
<p><strong>Makefile</strong> 写好编译策略后，使用 <code>make</code> 实现自动化编译</p>
<p>从程序到可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">s[source file]--compile--&gt;obj[object file]</span><br><span class="line">obj--link--&gt;p[Program]</span><br></pre></td></tr></table></figure>
<p>在 <code>link</code> 的过程中，有时候需要很多的链接函数和全局变量。在链接过程中由于目标文件（Object File）太多，所以我们将这些文件打包成，<strong>Windos</strong> 中为「库文件」（ .lib，Library File），在 <strong>UNIX</strong> 中为 <strong>Archive File</strong>（.a）。</p>
<h3 id="二-makefile-介绍"><a class="markdownIt-Anchor" href="#二-makefile-介绍"></a> 二、 Makefile 介绍</h3>
<p><strong>一般思路</strong>：</p>
<ul>
<li>准备好源文件</li>
<li>规定编译的规则，例如：
<ul>
<li>若没有编译过，则全部源文件编译链接</li>
<li>若其中几个源文件被修改过，则只编译被修改的源文件，再进行连接</li>
<li>如果头文件改变了，那么引用新的头文件，并链接</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="1-makefile-的规则"><a class="markdownIt-Anchor" href="#1-makefile-的规则"></a> 1、Makefile 的规则</h4>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example Rule:</span></span><br><span class="line">target... : prerequisites ...</span><br><span class="line">		command</span><br><span class="line">		...</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<p><code>target</code> ：目标文件，可以是 <strong>Objetc File</strong> 或者可执行文件，还可以是一个标签（Label）</p>
<p><code>prerequisites</code> ：先决条件，可以理解为生成 <code>target</code> 所需要的原料（文件 or 目标）</p>
<p><code>command</code> ：执行 make 需要执行的命令。（任意的 <strong>shell</strong> 命令）</p>
<blockquote>
<p>Makefile 规则：</p>
<p><u>实际上是一个文件依赖关系</u>， <code>target</code> 依赖于 <code>prerequisite</code> 的文件，其中的生成的规则策略由 <code>command</code> 给出。</p>
</blockquote>
<p>定义好依赖关系后，后续的那一行定义如何生成目标文件的操作系统命令，注意要以 Tab 开头。make 会比较 target 和 prerequisites 文件的修改日期，如果 prerequisites 日期比 target 要新或者 target 不存在的话，make 才会执行后续命令。</p>
<h4 id="2-make-如何工作的"><a class="markdownIt-Anchor" href="#2-make-如何工作的"></a> 2、make 如何工作的？</h4>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义我们的第一个 目标文件 策略, all 依赖于 main.o command.o display.o</span></span><br><span class="line"><span class="comment"># \ 为上下行连接符</span></span><br><span class="line"><span class="comment"># cc 执行链接生成 program 的可执行程序</span></span><br><span class="line"><span class="section">all: main.o command.o \</span></span><br><span class="line">	display.o</span><br><span class="line">  cc -o program main.o command.o display.o</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 由于 all 中的先决条件依赖于它们的源文件，</span></span><br><span class="line"><span class="comment"># 因此我们需要再定义一下各个先决条件的生成策略</span></span><br><span class="line"><span class="section">main.o: main.c main.h</span></span><br><span class="line">		cc -c main.c</span><br><span class="line"><span class="section">command: command.c command.h</span></span><br><span class="line">		cc -c command.c</span><br><span class="line">		</span><br><span class="line"><span class="comment"># clean 功能用来删除生成的 *.o 和可执行文件。</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">		rm program main.o command.o</span><br></pre></td></tr></table></figure>
<p>在默认方式下，只输入 <code>make</code> 命令，那么：</p>
<ul>
<li><code>make</code> 会在当前目录下寻找「Makefile」或者「makefile」文件</li>
<li>如果找到，<code>make</code> 继续寻找文件中的第一个目标文件 <code>target</code>， 在上面的例子中，<code>make</code> 会找到 <code>all</code> 这个目标，并把这个文件作为<strong>最终的</strong>的目标文件</li>
<li>如果 <code>all</code> 依赖的 .o 文件不存在，那么 <code>make</code> 会执行后面定义的策略生成 <code>all</code> 的先决条件。</li>
<li>如果 <code>all</code> 依赖的 .o 文件存在， <code>make</code> 会先检查一下目标文件和它们的先决条件的修改日期，如果先决条件更新了，那么 <code>make</code> 会更新生成新的目标文件。</li>
<li><code>make</code> 会一层一层去寻找文件的依赖关系，直到把第一个<strong>终极目标文件</strong>整出来为止。</li>
<li>⚠️ 值得注意的是，<code>clean</code> 并没有出现在终极目标 <code>all</code> 的策略中，因此只输入 <strong>make</strong> 的命令是不会执行 <code>clean</code> 的功能。我们可以采用 <code>make clean</code> 来执行这个策略。</li>
</ul>
<h4 id="3-makefile-中使用变量"><a class="markdownIt-Anchor" href="#3-makefile-中使用变量"></a> 3、Makefile 中使用变量</h4>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 延用上面的例子</span></span><br><span class="line"><span class="section">all: main.o command.o \</span></span><br><span class="line">	display.o</span><br><span class="line">  cc -o program main.o command.o display.o  </span><br><span class="line"><span class="section">main.o: main.c main.h</span></span><br><span class="line">		cc -c main.c</span><br><span class="line"><span class="section">command: command.c command.h</span></span><br><span class="line">		cc -c command.c</span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">		rm program main.o command.o</span><br></pre></td></tr></table></figure>
<p>在这个 Makefile 中，我们可以看到我们把我们需要的先决条件全部列出来，这个在文件不多时并不复杂，但是如果遇到文件量较多的工程时，采用这方式可能会让我们漏掉一两个文件，从而导致编译失败。为了 makefile 的易维护，在 makefile 中我们可以使用变量。</p>
<blockquote>
<p><strong>「Makefile 的变量其实也就是一个字符串，理解成 C 语言中的宏定义可能会更好」</strong></p>
</blockquote>
<p>比如我们将所有的 .o 文件声明为一个变量 <code>objects</code> ，我们可以在 makefile 的一开始就这样定义好：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o command.o display.o</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以很方便的在 makefile 中采用 <code>$(objects)</code> 的方式来使用这个变量了，下面我们改良一下我们的例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义变量 objects</span></span><br><span class="line">objects = main.o command.o display.p</span><br><span class="line"><span class="comment"># 编写策略</span></span><br><span class="line">all : <span class="variable">$(objects)</span></span><br><span class="line">		cc -o program <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c main.h</span><br><span class="line">		cc -o main.c</span><br><span class="line">command.o : command.c command.h</span><br><span class="line">		cc -o command.c </span><br><span class="line">display.o : display.c display.o</span><br><span class="line">		cc -o display.c</span><br><span class="line">		</span><br><span class="line">clean : </span><br><span class="line">		rm progam <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这个时候若有新的 .o 文件加入，我们只需要修改 <code>objects</code> 变量以及新增目标策略jiukeyiile。</p>
<h4 id="4-让-make-自动推导"><a class="markdownIt-Anchor" href="#4-让-make-自动推导"></a> 4、让 make 自动推导</h4>
<p><strong>GNU</strong> 的 make 很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们没有必要在每一个 .o 文件后面都写上类似的命令。 <strong>make</strong> 会自动识别，自己推导命令。</p>
<p>下面我们继续将我们的例子优化：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o command.o display.o</span><br><span class="line">all : <span class="variable">$(objects)</span></span><br><span class="line">		cc -o program <span class="variable">$(objects)</span></span><br><span class="line">		</span><br><span class="line"><span class="section">main.o: main.h</span></span><br><span class="line"><span class="section">command.o: command.h</span></span><br><span class="line"><span class="section">display.o: display.h</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">		rm program <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这种方法，也就是 make 的「隐晦规则」。 <code>.PHONY</code> 表示 clean 是一个伪目标文件。</p>
<h4 id="6-清空目标文件的规则"><a class="markdownIt-Anchor" href="#6-清空目标文件的规则"></a> 6、清空目标文件的规则</h4>
<p>每个 <strong>Makefile</strong> 中都应该写一个清空目标文件 （ .o 和执行文件 ）的规则，这不仅便于重新编译，也很利于保持文件的清洁。可以说是「程序猿」的一种「<strong>修养</strong>」，一般的风格都是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">		rm program <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>更稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">		-rm program <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>这里又出现了 <code>.PHONY</code> ，这里表示 <strong>clean</strong> 是一个「伪目标」，在 <strong>rm</strong> 命令前面加一个 <strong>-</strong> 表示：也许某些文件出现问题，但是不用在意，继续执行。</p>
<blockquote>
<p>冷知识：一个不成文的规定：「clean 从来都是放在 Makefile 文件的最后。」</p>
</blockquote>
<h3 id="三-makefile-的细节"><a class="markdownIt-Anchor" href="#三-makefile-的细节"></a> 三、Makefile 的细节</h3>
<h4 id="1-makefile-里有什么"><a class="markdownIt-Anchor" href="#1-makefile-里有什么"></a> 1、Makefile 里有什么？</h4>
<p>Makefile 里面主要包含了五个东西：显示规则，隐晦规则，变量定义，文件指示和注释。</p>
<blockquote>
<p>1）显示规则：如何生成一个或者多个目标文件，这个是由 <strong>Makefile</strong> 的书写者明显指出的，包括要生成的文件，文件的依赖文件以及生成的命令。</p>
<p>2）隐晦规则：依靠 <strong>make</strong> 的自动推导空能，我们可以简略书写 <strong>Makefile</strong>，这个是由 <strong>make</strong> 所支持的</p>
<p>3）变量定义：在 <strong>Makefile</strong> 中我们要定义一系列的变量，可以把这些变量当成 <strong>C</strong> 语言中的 <strong>宏定义</strong> 来理解。</p>
<p>4）文件指示：文件指示包含了三个部分：</p>
<ul>
<li>第一部分是在 <strong>Makefile</strong> 中引用另一个 <strong>Makefile</strong>，就像 <strong>C</strong> 语言中的 include 一样；</li>
<li>第二部分是根据某些情况制定 <strong>Makefile</strong> 中的有效部分，就像 <strong>C</strong> 语言中的预编译 <code>#if</code> 一样；</li>
<li>第三部分是定义一个多行的命令。</li>
<li>注释： <strong>Makefile</strong> 中只有行注释，采用 <code>#</code> 开头。</li>
</ul>
</blockquote>
<h4 id="2-makefile-的文件名"><a class="markdownIt-Anchor" href="#2-makefile-的文件名"></a> 2、Makefile 的文件名</h4>
<p>默认情况下，<code>make</code> 命令会在当前的目录下按顺序寻找文件名为 “GNUmakefile”、“makefile”、“Makefile&quot;的文件，找到了解释这个文件。在这三个文件名中，最好使用&quot;Makefile&quot;这个文件名。（比较显目和好看）最好不要用&quot;GNUmakefile”，这个文件是 GNU 的 make 识别的。有些编译器只支持小写的&quot;makefile&quot;，但基本上来说大部分 make 都支持 “Makefile” 和 “makefile” 两种文件名。</p>
<p>同样，如果需要用别的文件名来写 Makefile，比如 “Make.Linux”, “Make.Solaris”, &quot;Make.mac&quot;等。可以使用：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -f Make.Linux </span><br><span class="line">make -file Make.AIX</span><br></pre></td></tr></table></figure>
<h4 id="3-引用其他的-makefile"><a class="markdownIt-Anchor" href="#3-引用其他的-makefile"></a> 3、引用其他的 Makefile</h4>
<p>在 Makefile 中使用 <code>include</code> 关键字可以把别的 Makefile 包含进来。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;FileName&gt; <span class="comment"># FileName 可以是当前操作系统 Shell 的文件模式</span></span><br></pre></td></tr></table></figure>
<p>文件名：如果文件都诶呦指定绝对路径或是相对路径， make 会在当前目录下首先须按照，如果当前目录下没有找到，make 还会在下面几个目录下寻找：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 如果 make 命令有 “-I” 或 &quot;——include-dir&quot; 参数，那么 make 就会在这个参数所制定的目录下去寻找。</span></span><br><span class="line">make -I &lt;dir&gt;</span><br><span class="line"><span class="comment"># 2 如果目录 /include (一般是： /usr/local.bin 或 /usr/include) 存在的话，make 也会去寻找。</span></span><br></pre></td></tr></table></figure>
<h4 id="4-环境变量-makefiles"><a class="markdownIt-Anchor" href="#4-环境变量-makefiles"></a> 4、环境变量 MAKEFILES</h4>
<p>如果在当前环境中定义了环境变量 MAKEFILES，那么，make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其他的 Makefile，并用空格分隔。</p>
<p>与 include <strong>不同</strong>的是，从这个环境变量中引入的 Makfile 的“目标”<strong>不会起作用</strong>，如果环境变量中的定义的文件发现错误，make 也会不理。</p>
<p>不建议使用这个环境变量，一旦定义 MAKEFILES 环境变量，其他的 make 均会收到影响。这一点也可以用来<strong>检查错误</strong>，如果有一天你突然发现你的 Makefile 执行结果很离谱，不妨看看这个 MAKEFILES 环境变量是不是被定义了。</p>
<h4 id="5-make-的工作方式"><a class="markdownIt-Anchor" href="#5-make-的工作方式"></a> 5、make 的工作方式</h4>
<p><strong>GNU</strong> 的 make 工作时的执行步骤：</p>
<ul>
<li>1）读入所有 Makefile</li>
<li>2）读入被 <code>include</code> 的其他 Makefile</li>
<li>3）初始化文件中的变量</li>
<li>4）推导隐晦规则，并分析所有规则</li>
<li>5）为所有的目标文件创建依赖关系链</li>
<li>6）根据依赖关系，决定哪些目标要重新生成</li>
<li>7）执行生成命令</li>
</ul>
<h4 id="6-makefile-书写规则"><a class="markdownIt-Anchor" href="#6-makefile-书写规则"></a> 6、Makefile 书写规则</h4>
<p>规则包括两个部分：一个是<strong>依赖关系</strong>，一个是<strong>生成目标方法</strong></p>
<p>在 Makefile 中，规则的顺序是十分重要的，因为对于一个 Makefile 来说，只有一个终极目的：<strong>第一个目标文件的生成</strong>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 规则语法</span></span><br><span class="line"><span class="comment"># target : prerequisites</span></span><br><span class="line"><span class="comment">#				command...</span></span><br><span class="line">main.o : main.c main.h <span class="comment">#  main 模块</span></span><br><span class="line">		cc -o main.c</span><br></pre></td></tr></table></figure>
<p>在生成过程中，make 都会检测 <code>target</code> 和 <code>prerequisites</code> 的时间，如果 <code>prerequisites</code> 更新了，那么 make 才会进行生成，反之不进行生成。</p>
<p>如果命令太长，可以使用反斜杠 <code>\</code> 作为换行符。</p>
<p>一般来说，make 会以 <strong>UNIX</strong> 的标准 Shell，也就是 <strong>/bin/sh</strong> 来执行命令。</p>
<h4 id="7-在规则中使用通配符"><a class="markdownIt-Anchor" href="#7-在规则中使用通配符"></a> 7、在规则中使用通配符</h4>
<p>如果我们想定义一系列比较类似的文件，我们可以采用通配符。make 中支持三个通配符 <code>*</code>, <code>?</code>, <code>[...]</code></p>
<p><code>~</code> 表示当前用户的 <code>$HOME</code> 目录下的目录。</p>
<p><code>*</code> 表示任意，比如要所有的 .c 文件，可以写 <code>*.c</code> 来实现。</p>
<h4 id="8-文件搜索"><a class="markdownIt-Anchor" href="#8-文件搜索"></a> 8、文件搜索</h4>
<p>在一些大的工程中，有大量的温元件，我们通常的做法是把这些许多的源文件分类，并存放在不同的目录中。所以，当 make 需要去寻找文件的依赖关系时，我们可以在文件前加上路径。最好的方法是告诉 make 一个路径，让它自己去找。</p>
<p>Makefile 文件中的特殊变量 “VPATH” 就是完成这个功能的，如果没有指明这个变量，make 只会在当前的目录中去寻找依赖文件和目标文件，如果定义了这个变量，那么make就会在当前目录以及 “VPATH” 的路径下去寻找。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<p>上面定义的两个目录，“src” 和 “…/headers”，make 会按照这个顺序进行搜索，目录由「冒号」分隔。</p>
<p>还可以使用 make 的关键字 “vpath” （它不是变量，只是一个关键字，注意全小写）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 符合模式 &lt;pattern&gt; 的文件制定搜索目录 &lt;directories&gt;</span></span><br><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;</span><br><span class="line"><span class="comment"># 清除符合模式 &lt;pattern&gt; 的文件的搜索目录</span></span><br><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt;</span><br><span class="line"><span class="comment"># 清楚所有已经被设置好的文件搜索目录</span></span><br><span class="line"><span class="keyword">vpath</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;pattern&gt;</code> 需要包含 “%” 字符。&quot;%&quot; 的意思是匹配零或若干字符，例如，&quot;%.h&quot; 表示所有以 “.h” 结尾的文件。 &lt;pattern&gt; 制定了要搜索的文件集</p>
<p><code>&lt;directories&gt;</code> 则制定了文件集的搜索目录。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要求 make 在 &quot;../headers&quot; 目录下搜索所有以 &quot;.h&quot; 结尾的文件。</span></span><br><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>
<h4 id="9-伪目标"><a class="markdownIt-Anchor" href="#9-伪目标"></a> 9、伪目标</h4>
<p>上面的例子中我们提到了<code>.PHONY ：clean</code> 中的 <code>clean</code> 是一个伪目标，这里来解释一下。</p>
<p>在 Makefile 中的我们并不需要生成一个 <code>clean</code> 的文件，所以「伪目标」并不是一个文件，只是一个标签（Label）。由于定义了它是一个伪目标，因此 make 无法生成它的依赖关系和决定它是否要执行。</p>
<h4 id="10-多个目标"><a class="markdownIt-Anchor" href="#10-多个目标"></a> 10、多个目标</h4>
<p>Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能其合并起来。这里我们可以使用<strong>自动化变量</strong><code>$@</code>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">outputA ouputB : text.g</span><br><span class="line">		generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">outputA : text.g</span><br><span class="line">		generate text.g -big &gt; outputA</span><br><span class="line">outputB : text.g</span><br><span class="line">		generate text.g -little &gt;outputB</span><br></pre></td></tr></table></figure>
<p>其中 <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个 Makefile 的函数，函数名为 subst，后面的为参数。<code>$@</code> 表示目标的集合，就像一个数组，<code>$@</code> 依次取出目标，并执行命令。</p>
<h4 id="11-静态模型"><a class="markdownIt-Anchor" href="#11-静态模型"></a> 11、静态模型</h4>
<h4 id="12-自动生成依赖性"><a class="markdownIt-Anchor" href="#12-自动生成依赖性"></a> 12、自动生成依赖性</h4>
<p>我们之前已经提到了 make 的自动推导功能，但是仅仅是自动推导功能，在修改单个目标文件的头文件或者源文件时，仍需要小心的修改 Makefile 文件。这是一个很缺乏维护性的过程。为此，我们可以使用 <strong>C/C++</strong> 编译的一个功能。</p>
<p>大多数 <strong>C/C++</strong> 编译器都支持一个 “-M” 的选项，即自动寻找源文件中包含的头文件，并自动生成一个依赖关系。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc -M main.c</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="section">main.o: main.c main.h</span></span><br></pre></td></tr></table></figure>
<p>这样利用编译器自动生成的依赖关系，我们就不比手动书写若干文件的依赖关系。</p>
<p>注意：如果使用 <strong>GNU</strong> 的 <strong>C/C++</strong> 编译器，得使用 “——MM” 参数，不然 “-M” 参数会把一些标准库的头文件也包含进来。</p>
<h4 id="13-嵌套执行-make"><a class="markdownIt-Anchor" href="#13-嵌套执行-make"></a> 13、嵌套执行 make</h4>
<hr />
<p>后面的暂时用不上了，写个框架以后填坑 😄</p>
<h3 id="四-使用变量"><a class="markdownIt-Anchor" href="#四-使用变量"></a> 四、使用变量</h3>
<p>参考前面的部分就差不多了</p>
<h4 id="环境变量-目标变量-模式变量"><a class="markdownIt-Anchor" href="#环境变量-目标变量-模式变量"></a> 环境变量、目标变量、模式变量</h4>
<h3 id="五-使用函数"><a class="markdownIt-Anchor" href="#五-使用函数"></a> 五、使用函数</h3>
<h3 id="六-make-的运行"><a class="markdownIt-Anchor" href="#六-make-的运行"></a> 六、make 的运行</h3>
<h3 id="七-隐含规则"><a class="markdownIt-Anchor" href="#七-隐含规则"></a> 七、隐含规则</h3>
<h3 id="八-使用-make-更新函数库文件"><a class="markdownIt-Anchor" href="#八-使用-make-更新函数库文件"></a> 八、使用 make 更新函数库文件</h3>
<p>一个函数库文件由多个文件组成。你可以以如下的格式制定函数库文件及其组成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure>
<p>注意，这个并不是一个命令，而是一个目标和依赖的定义。一般来说，这种用法是为了 <code>ar</code> 命令来服务的：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foolib(hack.o):hack.o</span></span><br><span class="line">ar cr foolib hack.o</span><br><span class="line"><span class="section">foolib(*.o):.....</span></span><br></pre></td></tr></table></figure>
<h4 id="1-函数库成员的隐含规则"><a class="markdownIt-Anchor" href="#1-函数库成员的隐含规则"></a> 1、函数库成员的隐含规则</h4>
<p>当 make 搜索一个目标的隐含规则时，一个特殊的特性时，如果这个目标是 “a(m)” 形式的，其会把目标变成 “(m)”。如果此时，我们的成员都是 “%.o” 的模式定义，并且如果我们使用 “make foo.a(bar.o)” 的形式调用 Makefile 时，隐含规则会去找 “bar.o” 的规则，如果没有定义 bar.o，那么内建隐含规则生效，make 会去寻找 bar.c 文件来生成 bar.o，如果找得到的话，make 执行的命令大致如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc -c bar.c -o bar.o</span><br><span class="line">ar r foo.a bar.o</span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure>
<h4 id="2-后缀规则"><a class="markdownIt-Anchor" href="#2-后缀规则"></a> 2、后缀规则</h4>
<h4 id="3-注意事项"><a class="markdownIt-Anchor" href="#3-注意事项"></a> 3、注意事项</h4>
<hr />
<p>参考自 <strong>CSDN</strong> 论坛：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38391755/article/details/80380786/">博客地址</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Makefile/" rel="tag"># Makefile</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/23/STM32HAL%E5%BA%93%E5%AD%A6%E4%B9%A0MacOS%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94SPI%E9%80%9A%E4%BF%A1/" rel="prev" title="STM32HAL库学习（6）——SPI通信">
      <i class="fa fa-chevron-left"></i> STM32HAL库学习（6）——SPI通信
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/14/How-to-use-git-ssh/" rel="next" title="How to Use Git and SSH">
      How to Use Git and SSH <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text"> 目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text"> 一、几个常识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-makefile-%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text"> 二、 Makefile 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-makefile-%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">3.1.</span> <span class="nav-text"> 1、Makefile 的规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-make-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-number">3.2.</span> <span class="nav-text"> 2、make 如何工作的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-makefile-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text"> 3、Makefile 中使用变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%AE%A9-make-%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC"><span class="nav-number">3.4.</span> <span class="nav-text"> 4、让 make 自动推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%B8%85%E7%A9%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-number">3.5.</span> <span class="nav-text"> 6、清空目标文件的规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-makefile-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">4.</span> <span class="nav-text"> 三、Makefile 的细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-makefile-%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-number">4.1.</span> <span class="nav-text"> 1、Makefile 里有什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-makefile-%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="nav-number">4.2.</span> <span class="nav-text"> 2、Makefile 的文件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%BC%95%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84-makefile"><span class="nav-number">4.3.</span> <span class="nav-text"> 3、引用其他的 Makefile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-makefiles"><span class="nav-number">4.4.</span> <span class="nav-text"> 4、环境变量 MAKEFILES</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-make-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text"> 5、make 的工作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-makefile-%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99"><span class="nav-number">4.6.</span> <span class="nav-text"> 6、Makefile 书写规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%9C%A8%E8%A7%84%E5%88%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">4.7.</span> <span class="nav-text"> 7、在规则中使用通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="nav-number">4.8.</span> <span class="nav-text"> 8、文件搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="nav-number">4.9.</span> <span class="nav-text"> 9、伪目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E5%A4%9A%E4%B8%AA%E7%9B%AE%E6%A0%87"><span class="nav-number">4.10.</span> <span class="nav-text"> 10、多个目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E9%9D%99%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.11.</span> <span class="nav-text"> 11、静态模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-number">4.12.</span> <span class="nav-text"> 12、自动生成依赖性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8C-make"><span class="nav-number">4.13.</span> <span class="nav-text"> 13、嵌套执行 make</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text"> 四、使用变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%E7%9B%AE%E6%A0%87%E5%8F%98%E9%87%8F-%E6%A8%A1%E5%BC%8F%E5%8F%98%E9%87%8F"><span class="nav-number">5.1.</span> <span class="nav-text"> 环境变量、目标变量、模式变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text"> 五、使用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-make-%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="nav-number">7.</span> <span class="nav-text"> 六、make 的运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99"><span class="nav-number">8.</span> <span class="nav-text"> 七、隐含规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-%E4%BD%BF%E7%94%A8-make-%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-number">9.</span> <span class="nav-text"> 八、使用 make 更新函数库文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E5%BA%93%E6%88%90%E5%91%98%E7%9A%84%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99"><span class="nav-number">9.1.</span> <span class="nav-text"> 1、函数库成员的隐含规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99"><span class="nav-number">9.2.</span> <span class="nav-text"> 2、后缀规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">9.3.</span> <span class="nav-text"> 3、注意事项</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chris"
      src="https://gitee.com/zhuang-jiaxin_gitee/pictures/raw/master/img/0df431adcbef76096e34ebdc26dda3cc7cd99eb1-20210706060646187.jpeg">
  <p class="site-author-name" itemprop="name">Chris</p>
  <div class="site-description" itemprop="description">"I hope that I am a pioneer and my efforts can bring better technology and things to everyone."</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chrisz-nju" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chrisz-nju" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chris</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
